---
title: 动态存储管理
category: algorithm
---

[动态存储管理(续)](/2013/10/25/dynamic-memory-management-add)

数据结构的中的每个元素都有一定的内存位置，在程序执行过程中，数据元素的存取都是经过对应的存储单元进行的。动态存储管理的基本问题使系统如何应用户提出**请求**分配，又如何回收那些用户不再使用而**释放**的内存，以备新内存**请求**时重新进行分配。
<!--more-->

## 1. 概述

不管什么样的待太存储管理系统，在刚开始工作时，整个内存去使一个**空闲块**（在编译程序中称之为堆）。随着用户进入系统先后提出存储请求，系统则依次进行分配。系统运行初期，整个内存被分为包含若干占用块的**低地址区**和是一个空闲块**高地址区**

通常对请求分配内存有两种做法：

- 继续从高地址区进行分配不理会低地址区的空闲块，直到分配无法进行在回收空闲块
- 巡视整个内存区所有空闲块并找到一个合适的进行分配，用户一旦结束运行即将它占用的内存释放为空闲块，并由系统维护一个可用空闲块的链表

## 2. 可利用空间表，分配方法

可利用空间表又称**存储池**，根据系统运行的不同情况，可利用空间表有但中不同的结构形式：

### 2.1 所有用户请求分配的存储量大小相同

系统运行使可将内存区按所需大小分配成若干大小相同的块，然后用指针链接成一个可利用空间表。由于表中节点大小相同故分配时无需查找

### 2.2 用户请求分配的存储量有若干不同大小

一般情况下建立若干可利用空间表，统一链表中节点的大小相同。当节点大小和请求分配的量相同的链表为空时，需要查询节点较大的链表，从中取出一部分分配给用户而剩余的部分按大小插入相应的链表中。频繁的小块分配和回收使大结点被分割成小块，若使系统能继续运行，需要进行**存储紧缩**操作

### 2.3 系统分配给用户的内存块大小不固定

操作系统通常的可利用空间表属于这种类型。

系统刚开始运行时，所有内存就是一个空闲块，可利用空间表就是一个节点。由于可利用空间表中的结点大小不同，则分配就成为一个问题，通常有以下3种分配策略：

- **首次拟合法**：将从表头开始查找到的第一个大小不小与`n`的块分配给用户
- **最佳拟合法**：在空间表中找到大小不小于`n`而且最接近`n`的块分配给用户
- **最差拟合法**：将表中大小不小于`n`且最大的块分配给用户

上述2种策略各有所长。一般来说，最佳拟合法适用于请求分配内存的大小范围较广的系统，最差拟合使链表中的节点大小趋于均匀，因此它适用于请求分配的内存大小范围较窄的系统

因此根据不同情景采用不同的方法，在选择时需要考虑下列因素：

- 用户的逻辑要求
- 请求分配量的大小分布
- 分配和释放的频率以及效率对系统的重要性

## 3. 边界标识法

### 3.1 可利用空间表结构

``` c++
typedef struct WORD { //内存字类型
	int	tag;	//标识块：0空闲，1占用
	int	size;	//头部域，块大小
	WORD	*rlink;
	OtherType other;  //字的其他部分
	union {	//head和foot分别是结点的第一个字和最后一个字
		WORD	*llink;
		WORD	*uplink;
	};
} WORD, Head, Foot, *Space;
#define FootLoc(p) p+p->size-1 //指向p底部
```

### 3.2 分配算法

我们采用首次拟合法进行分配，算法解析插入注释中：

``` c++
const	int e = 16; // 不保留<=e的剩余量
Space alloc_bound_tag (Space &pav, int n) {
  // 若有不小于n的空闲块，则分配相应的存储块，并返回其首地址；
  // 否则返回NULL。
  // 若分配后可利用空间表不空，则pav指向表中刚分配过的结点的后继结点
	Space p;
	       // 查找不小于n的空闲块
	for(p = pav; p && p->size < n && p->rlink != pav; p=p->rlink);
	if (!p || p->size < n) return NULL;// 找不到，返回空指针
	else {                            // p指向找到的空闲块
		Space f = FootLoc(p);           // 指向底部
		pav = p->rlink;                 // pav指向*p结点的后继结点。
		if (p->size-n <= e) {           // 整块分配，不保留<=e的剩余量
		if (pav == p) pav = NULL;     // 可利用空间表变为空表
	else {                        // 在表中删除分配的结点
		pav->llink = p->llink;  p->llink->rlink = pav;
	}
	p->tag = f->tag = 1;          // 修改分配结点的头部和底部标志
	} else {                        // 分配该块的后n个字
		f->tag = 1;                   // 修改分配块的底部标志
		p->size -= n;                 // 置剩余块大小
		f = FootLoc(p);               // 指向剩余块底部
		f->tag = 0;   f->uplink = p;  // 设置剩余块底部
		p = f+1;                      // 指向分配块头部
		p->tag = 1;   p->size = n;    // 设置分配块头部
	}
	return p;         // 返回分配块首地址
	}
}
```

### 3.3 回收算法

系统回收空间时，为了使物理地址毗邻的空闲块结合成一个尽可能大的节点，则首先需要检查刚释放的占用块的左，右结点是否为空闲块。根据左右节点是否为空闲块可分为4种情况：

#### (1). 左右邻区均为占用块

``` c++
p->tag = 0; FootLoc(p)->uplink = p; FootLoc(p)->tag = 0;
if(!pav) pav = p->llink = p->rlink = p;
else {
	q = pav->link;
	p->rlink = pav; p->llink = q;
	q->rlink = pav->llink = p;
	pav = p; //令刚释放的结点为下次首先查询的结点
}
```

#### (2). 左邻区为空闲块，又邻区为占用块

``` c++
n = p->size;
s = (p-1)->uplink; //左邻空闲块的头部地址
s->size += n;
f = p+n-1; f->uplink = s; f->tag = 0;
```

#### (3). 右邻区为空闲块，左邻区为占用块

``` c++
t = p + p->size;
p->tag = 0;
q = t->llink;
p->llink = q; q->rlink = p;
q1 = t->rlink;
p->rlink = q1; q1->llink = p;
p->size += t->size;
FootLoc(t)->uplink = p;
```

#### (4). 左右邻区均为空闲块

``` c++
n = p->size;
s = (p-1)->uplink;
t = p+p->size;
s->size += n + t->size;
q = t->llink; q1 = t->rlink;
q->rlink = q1; q1-llink = q;
FootLoc(t)->uplink = s;
```

